# -*- coding:utf-8 -*- 
# Syscall module: building ropchains performing syscalls
from ropgenerator.core.IO import str_special, banner, str_bold, error
from enum import Enum


from ropgenerator.main.Utils import parse_function, parse_offset, parse_keep_regs, parse_bad_bytes, parse_range
from ropgenerator.core.Architecture import *
from ropgenerator.main.Load import loaded_binary
from ropgenerator.core.Gadget import set_gadgets_offset
from ropgenerator.main.Scanner import set_binary_offset, get_readwrite_memory
from ropgenerator.core.ChainingEngine import *
import ropgenerator.exploit.syscall.SyscallLinuxX64 as LinuxX64
import ropgenerator.exploit.syscall.SyscallLinuxX86 as LinuxX86
from ropgenerator.core.IO import *
import ropgenerator.exploit.Systems as Systems

###################
# SYSCALL COMMAND #
###################

OPTION_OUTPUT = '--output-format'
OPTION_OUTPUT_SHORT = '-f'
# Options for output
OUTPUT_CONSOLE = 'console'
OUTPUT_PYTHON = 'python'
OUTPUT_RAW = 'raw'
OUTPUT = None # The one choosen 

OPTION_BAD_BYTES = '--bad-bytes'
OPTION_BAD_BYTES_SHORT = '-b'

OPTION_KEEP_REGS = '--keep-regs'
OPTION_KEEP_REGS_SHORT = '-k'

OPTION_LIST = "--list"
OPTION_LIST_SHORT = "-l"

OPTION_FUNCTION = "--call"
OPTION_FUNCTION_SHORT = "-c" 

OPTION_OFFSET="--offset"
OPTION_OFFSET_SHORT = "-off"

OPTION_SHORTEST = '--shortest'
OPTION_SHORTEST_SHORT = '-s'

OPTION_LMAX = '--max-length'
OPTION_LMAX_SHORT = '-m'

OPTION_HELP = "--help"
OPTION_HELP_SHORT = "-h"

OPTION_RW_MEMORY = '--rw-memory'
OPTION_RW_MEMORY_SHORT = '-rw'

CMD_SYSCALL_HELP =  banner([str_bold("'syscall' command"),\
                    str_special("(Call system functions with ROPChains)")])
CMD_SYSCALL_HELP += "\n\n\t"+str_bold("Usage:")+\
"\n\t\tsyscall [OPTIONS]"
CMD_SYSCALL_HELP += "\n\n\t"+str_bold("Options")+":"
CMD_SYSCALL_HELP += "\n\t\t"+str_special(OPTION_FUNCTION_SHORT)+","+\
    str_special(OPTION_FUNCTION)+" <sys> <func>\t Call a system function"
CMD_SYSCALL_HELP += "\n\n\t\t"+str_special(OPTION_BAD_BYTES_SHORT)+","+str_special(OPTION_BAD_BYTES)+" <bytes>\t Bad bytes for payload.\n\t\t\t\t\t Expected format is a list of bytes \n\t\t\t\t\t separated by comas (e.g '-b 0A,0B,2F')"
CMD_SYSCALL_HELP += "\n\n\t\t"+str_special(OPTION_KEEP_REGS_SHORT)+","+str_special(OPTION_KEEP_REGS)+" <regs>\t Registers that shouldn't be modified.\n\t\t\t\t\t Expected format is a list of registers \n\t\t\t\t\t separated by comas (e.g '-k edi,eax')"
CMD_SYSCALL_HELP += "\n\n\t\t"+str_special(OPTION_OFFSET_SHORT)+","+\
    str_special(OPTION_OFFSET)+" <int>\t Offset to add to gadget addresses"   
CMD_SYSCALL_HELP += "\n\n\t\t"+str_special(OPTION_RW_MEMORY_SHORT)+","+\
    str_special(OPTION_RW_MEMORY)+" <range>\t Usable read-write memory"
CMD_SYSCALL_HELP += "\n\n\t\t"+str_special(OPTION_LMAX_SHORT)+","+str_special(OPTION_LMAX)+" <int>\t Max length of the ROPChain in bytes"
CMD_SYSCALL_HELP += "\n\n\t\t"+str_special(OPTION_SHORTEST_SHORT)+","+str_special(OPTION_SHORTEST)+"\t\t Find the shortest matching ROP-Chains"

CMD_SYSCALL_HELP += "\n\n\t\t"+str_special(OPTION_LIST_SHORT)+","+\
    str_special(OPTION_LIST)+" [<system|arch> ...]\t List supported syscalls"
CMD_SYSCALL_HELP += "\n\n\t\t"+str_special(OPTION_OUTPUT_SHORT)+","+\
    str_special(OPTION_OUTPUT)+\
    " <fmt> Output format for ropchains.\n\t\t\t\t\t Expected format is one of the\n\t\t\t\t\t following: "+\
    str_special(OUTPUT_CONSOLE)+','+str_special(OUTPUT_PYTHON)
    
CMD_SYSCALL_HELP += "\n\n\t\t"+str_special(OPTION_HELP_SHORT)+","+str_special(OPTION_HELP)+"\t\t Show this help"
CMD_SYSCALL_HELP += "\n\n\t"+str_bold("Supported systems")+": "+', '.join([str_special(s) for s in Systems.available_systems_str()])
CMD_SYSCALL_HELP += "\n\n\t"+str_bold("Supported achitectures")+": "+', '.join([str_special(s) for s in available_archs_str()])
CMD_SYSCALL_HELP += "\n\n\t"+str_bold("Function format")+": "+\
    str_special("function")+"( "+str_special("arg1")+","+str_special(" ...")+\
    "," + str_special(" argN")+")"
CMD_SYSCALL_HELP += "\n\n\t"+str_bold("Range format")+": "+\
    str_special("<lower_address>")+","+str_special("<higher_address>")
CMD_SYSCALL_HELP += "\n\n\t"+str_bold("Examples")+": "+\
    "\n\t\tsyscall -f python -c LINUX mprotect(0x123456, 200, 7)"+\
    "\n\t\tsyscall -c LINUX execve('/bin/sh\\x00', 0, 0) -rw 0x23000,0x241ff"+\
    "\n\t\tsyscall -l LINUX X64 X86"
    
def print_help():
    print(CMD_SYSCALL_HELP)

def syscall(args):
    global OUTPUT, OUTPUT_CONSOLE, OUTPUT_PYTHON

    if( not args):
        print_help()
        return
    OUTPUT = OUTPUT_CONSOLE
    funcName = None
    offset = 0
    i = 0
    seenOutput = False
    seenFunction = False
    seenBadBytes = False
    seenKeepRegs = False
    seenShortest = False
    seenLmax = False
    seenOffset = False
    seenRw = False
    bad_bytes = []
    keep_regs = []
    lmax = get_default_lmax()
    additionnal_lmax = 0
    lower_valid_write_addr = 0
    higher_valid_write_addr = 0
    
    # Parsing arguments
    while i < len(args):
        arg = args[i]
        if( args[i] in [OPTION_LIST, OPTION_LIST_SHORT]):
            list_syscalls(args[1:]) # TODO 
            return 
        if( args[i] in [OPTION_BAD_BYTES, OPTION_BAD_BYTES_SHORT]):
            if( seenBadBytes ):
                error( "'" + arg + "' option should be used only once.")
                return 
            if( i+1 >= len(args)):
                error("Missing bad bytes after option '"+arg+"'")
                return 
            seenBadBytes = True
            (success, bad_bytes) = parse_bad_bytes(args[i+1])
            if( not success ):
                error(bad_bytes)
                return
            i = i+1
        elif( args[i] in [OPTION_KEEP_REGS, OPTION_KEEP_REGS_SHORT]):
            if( seenKeepRegs ):
                error( "'" + arg + "' option should be used only once.")
                return 
            if( i+1 >= len(args)):
                error("Missing registers after option '"+arg+"'")
                return 
            seenKeepRegs = True
            (success, keep_regs) = parse_keep_regs(args[i+1])
            if( not success ):
                error(keep_regs)
                return
            i = i+1
        elif( args[i] == OPTION_OFFSET or args[i] == OPTION_OFFSET_SHORT ):
            if( seenOffset ):
                error("'" + arg + "' option should be used only once.")
                return 
            if( i+1 >= len(args)):
                error("Missing output format after option '"+arg+"'")
                return
            (success, offset) = parse_offset(args[i+1])
            if( not success ):
                error(offset)
                return
            i = i+1
            seenOffset = True
        elif( args[i] in [OPTION_RW_MEMORY, OPTION_RW_MEMORY_SHORT]):
            if( seenRw ):
                error( "'" + arg + "' option should be used only once.")
                return 
            if( i+1 >= len(args)):
                error("Missing address range after option '"+arg+"'")
                return 
            seenRw = True
            (success, addr_range) = parse_range(args[i+1])
            if( not success ):
                error(addr_range)
                return
            (lower_valid_write_addr, higher_valid_write_addr) = addr_range
            i = i+1
        elif( args[i] in [OPTION_SHORTEST, OPTION_SHORTEST_SHORT]):
            if( seenShortest ):
                error("'" + arg + "' option should be used only once.")
                return 
            seenShortest = True
        elif( args[i] == OPTION_LMAX or args[i] == OPTION_LMAX_SHORT ):
            if( seenLmax ):
                error("'" + arg + "' option should be used only once.")
                return 
            if( i+1 >= len(args)):
                error("Missing length after option '"+arg+"'")
                return 
            (success, lmax) = parse_lmax(args[i+1])
            if( not success ):
                error(lmax)
                return 
            i = i +1 
            seenLmax = True
        elif( args[i] in [OPTION_FUNCTION, OPTION_FUNCTION_SHORT] ):
            if( not loaded_binary() ):
                error("You should load a binary before building ROPChains")
                return 
            elif( seenFunction ):
                error("Option '{}' should be used only once".format(args[i]))
                return  
            # Get system
            if( i+1 >= len(args)):
                error("Missing  argument after option '"+arg+"'")
                return
            system = Systems.str_to_target_system(args[i+1])
            if( system is None):
                error("Unsupported system '"+args[i+1]+"'")
                print(str_bold("\tSupported systems")+": "+', '.join([str_special(s) for s in Systems.available_systems_str()]))
                return
            i += 1
            # Get function 
            userInput = ''
            while( i+1 < len(args) and args[i+1][0] != "-"):
                userInput += args[i+1]
                i += 1
            (funcName, funcArgs ) = parse_function(userInput)
            if( not funcName):
                error(funcArgs)
                return
            seenFunction = True
            # Get additionnal lmax if string arguments
            for funcArg in funcArgs :
                if( isinstance(funcArg, str)):
                    additionnal_lmax += len(funcArg)*curr_arch_octets()*6 # 6 arbitrary max gadgets to copy one byte :/ 
        elif( args[i] in [OPTION_OUTPUT, OPTION_OUTPUT_SHORT]):
            if( seenOutput ):
                error("'" + arg + "' option should be used only once.")
                return 
            if( i+1 >= len(args)):
                error("Missing output format after option '"+arg+"'")
                return 
            if( args[i+1] in [OUTPUT_CONSOLE, OUTPUT_PYTHON]):
                OUTPUT = args[i+1]
                seenOutput = True
                i = i +1
            else:
                error("'" + args[i+1] + "' output format is not supported")
                return  
        elif( args[i] in [OPTION_HELP, OPTION_HELP_SHORT]):
            print_help()
            return 
        else:
            error("Error. Unknown option '{}'".format(args[i]))
            return 
        i += 1

    # Do the search 
    if( not funcName ):
        error("Missing function to call")
        return 
    else:
        # Check for valid writable memory to copy strings
        if( lower_valid_write_addr == 0 ):
            (lower_valid_write_addr,higher_valid_write_addr) = get_readwrite_memory() 
        # Set offset 
        set_gadgets_offset(offset)
        set_binary_offset(offset)
        # If no max len specified, adjust it for string arguments
        if( not seenLmax ):
            lmax += additionnal_lmax
        # Make syscall 
        params = SearchParametersBinding(keep_regs, bad_bytes, lmax, seenShortest, lower_valid_write_addr=lower_valid_write_addr, higher_valid_write_addr=higher_valid_write_addr)
        res = build_syscall(funcName, funcArgs, params, system)
        # Print result 
        if( res is None ):
            error("No matching ROPChain found")
        elif( isinstance(res, str) ):
            error(res)
            return 
        else:
            if( OUTPUT == OUTPUT_CONSOLE ):
                print(res.to_str_console(curr_arch_octets(), bad_bytes ))
            elif( OUTPUT == OUTPUT_PYTHON ):
                print(res.to_str_python(curr_arch_octets(), bad_bytes, True, False ))
        
        # Reset offset 
        set_gadgets_offset(0)
        set_binary_offset(0)
            

def build_syscall(func_name, parsed_args, params, system):
    """
    Make a syscall ROPChain
    system: one of syscall_available_systems
    """
    # Get target system
    if( system == Systems.TargetSystem.Linux and curr_arch_type() == ArchType.ARCH_X86 ):
        syscall = LinuxX86.get_syscall(func_name)
    elif( system == Systems.TargetSystem.Linux and curr_arch_type() == ArchType.ARCH_X64 ):
        syscall = LinuxX64.get_syscall(func_name)
    else:
        return ("System '{}' not supported yet".format(system.value))
    
    if( not syscall ):
        return ("Syscall '{}' not supported for system '{}'".format(\
        func_name, system.value))
    
    if( len(parsed_args) != syscall.nb_args()):
        return ("Error. Wrong number of arguments")

    # Build syscall
    return syscall.build(parsed_args, params, system)



def print_syscalls_list(syscall_dict):
    print("\t--------------------------------")
    for name in sorted(syscall_dict.keys()):
        print("\n\t"+str_payload(name)+":  "+str(syscall_dict[name]))

def list_syscalls(args):
    local_available_archs = [ArchType.ARCH_X86, ArchType.ARCH_X64]
    
    # Parse args 
    systems = []
    archs = []
    for arg in args:
        if( arg in Systems.available_systems_str() ):
            systems.append(Systems.str_to_target_system(arg))
        elif( is_supported_arch_str(arg) ):
            archs.append(str_to_arch_type(arg))
        else:
            error("Unknown system/arch: '{}'".format(arg))
            return
    if( (not systems) ):
        systems = Systems.available_systems()
    if( not archs):
        archs = available_archs_type()
    
    # Remove duplicates
    systems = list(set(systems))
    archs = list(set(archs))
    # Print 
    for system in systems:
        for arch in archs:
            if( system == Systems.TargetSystem.Linux and arch == ArchType.ARCH_X86 ):
                available = LinuxX86.available_syscalls()
                print(str_bold("\n\n\tSupported Linux X86 syscalls"))
                print_syscalls_list(available)
            elif( system == Systems.TargetSystem.Linux and arch == ArchType.ARCH_X64 ):
                available = LinuxX64.available_syscalls()
                print(str_bold("\n\n\tSupported Linux X64 syscalls"))
                print_syscalls_list(available)
    
