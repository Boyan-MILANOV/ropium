# -*- coding:utf-8 -*- 
# Utils module: useful functions to build exploits
import itertools
from ropgenerator.core.Architecture import *
from ropgenerator.main.Scanner import get_function_address, verify_bad_bytes, find_bytes
from ropgenerator.core.IO import *
from ropgenerator.core.ROPChain import ROPChain
from ropgenerator.core.ChainingEngine import *
import ropgenerator.exploit.Systems as Systems 
from ropgenerator.core.Expression import Binop
from ropgenerator.core.Symbolic import pycst_to_cppcst

# ----------------------------------------
# Set multiple registers to given values
# ----------------------------------------
def set_multiple_regs(args, params, system=None):
    """
    Creates a chain that sets multiple values into regs
    
    args is a list of pairs (reg, val) 
        OR a list of triples (reg, val, Comment) 
        
    params is a SearchParametersBinding

    """
    
    # Check if arguments contain regs that must be kept
    regs_to_set = set([a[0] for a in args])
    keep_regs = set(params.keep_regs)
    intersection = regs_to_set & keep_regs
    if( list(intersection)):
        return None
    
    # Check if string argument and no valid memory to write
    if( [x for x in args if isinstance(x[1], str)] and
        params.lower_valid_write_addr == 0):
        return None
    
    saved_lmax = params.lmax
    saved_keep_regs = params.keep_regs
    saved_lower_addr = params.lower_valid_write_addr
    
    # Try all possible permutations
    res = ROPChain()
    perms = list(itertools.permutations(args))
    for perm in perms:
        params.lmax = saved_lmax
        params.keep_regs = saved_keep_regs
        params.lower_valid_write_addr = saved_lower_addr
        res = ROPChain()
        for arg in perm:
            tmp_res = None
            if( len(arg) == 3 ):
                comment = arg[2]
            else:
                comment = ""
            saved_initial_comment = params.initial_pop_constant_comment
            params.initial_pop_constant_comment = comment
            if( isinstance(arg[1], int)):
                # Create search arguments
                dest = DestArg(DestType.REG, arg[0])
                assign = AssignArg(AssignType.CST, arg[1])
                tmp_res = search(dest, assign, params)
                if( tmp_res.found ):
                    tmp_chain = tmp_res.chain
                else:
                    tmp_chain = None
            elif( isinstance(arg[1], str)):
                tmp_res = store_string(arg[1], params, system)
                if( tmp_res[1] is None):
                    tmp_chain = None
                else:
                    tmp_chain = tmp_res[1]
                    if( tmp_chain.len() > params.lmax ):
                        raise Exception("store_string returned a chain that is too long!")
                    params.lower_valid_write_addr = tmp_res[0] + len(arg[1]) # Change lower addre to not erase the string with other str argument
                    # Put the address in the register
                    dest = DestArg(DestType.REG, arg[0])
                    assign = AssignArg(AssignType.CST, pycst_to_cppcst(tmp_res[0]), offset=True)
                    saved_lmax = params.lmax
                    params.lmax -= tmp_chain.len()
                    addr_to_reg = search(dest, assign, params)
                    if( not addr_to_reg.found ):
                        tmp_chain = None
                    else:
                        tmp_chain.add_chain(addr_to_reg.chain)
            else:
                raise Exception("Unknown argument type in popMultiple: '{}'".format(type(arg)))
            params.initial_pop_constant_comment = saved_initial_comment   
            
            if( tmp_chain is None ):
                # DEBUG TODO Check fail record?
                res = None
                break
            else:
                # If Reached max length, exit  
                if( params.lmax < tmp_chain.len() ):
                    res = None
                    break
                else:
                    params.lmax -= tmp_chain.len()
                    res.add_chain(tmp_chain)
                    params.keep_regs = params.keep_regs + [arg[0]]
        
        if( not res is None ):
            break
    
    # Restore params and return res 
    params.lmax = saved_lmax
    params.keep_regs = saved_keep_regs
    params.lower_valid_write_addr = saved_lower_addr
    if( not res is None ):
        return res
    return None
    
    
## ----------------
## Call functions
## ----------------
def _hexify_string(string):
    res = "'"
    for c in string:
        if( ord(c) >= 0x20 and ord(c) <= 0x7e ):
            res += c
        else:
            res += '\\x' + "{:02x}".format(ord(c))
    res += "'"
    return res

def call_function(func_name, func_args, params, system):
    """
    func_args : list of values (int or string)
    
    return str or None if fail
    return ROPChain if success
    """
    if( system == Systems.TargetSystem.Linux and curr_arch_type() == ArchType.ARCH_X86 ):
        return call_function_x86(func_name, func_args, params )
    elif( system == Systems.TargetSystem.Linux and curr_arch_type() == ArchType.ARCH_X64 ):
        return call_function_linux_x64(func_name, func_args, params )
    return "Not implemented yet for this system/arch"

def call_function_linux_x64(func_name, func_args, params):
    arg_regs = [RegX64.RDI, RegX64.RSI, RegX64.RDX, RegX64.RCX, RegX64.R8, RegX64.R9]
    
    # Check how many arguments 
    if( len(func_args) > 6 ):
        return "Doesn't support function call with more than 6 arguments for X64"
    
    # Get function address
    (name, addr) = get_function_address(func_name)
    if( addr is None ):
        return "Couldn't find function '{}' in the binary".format(func_name)
    
    # Check if bad bytes in function address 
    if( not verify_bad_bytes(addr, params.bad_bytes) ):
        return "'{}' address ({}) contains bad bytes".format(func_name, str_special('0x'+format(addr, '0'+str(curr_arch_octets()*2)+'x')))
    
    # Set arguments
    if( func_args ):
        if( params.lmax == 0 ):
            return "Couldn't call function (reached max length)"
        params.lmax -= 1
        # Build the ropchain with the arguments
        mapped_args = list(map(lambda x,y:(x,y) , arg_regs[:len(func_args)], func_args))
        commented_args = []
        for i in range(0,len(mapped_args)):
            if isinstance(mapped_args[i][1], str):
                comment = "Arg{}: ".format(i+1) + str_ropg(_hexify_string(mapped_args[i][1])) 
            else:
                comment = "Arg{}: ".format(i+1) + str_ropg(hex(mapped_args[i][1]))
            commented_args.append(mapped_args[i] + (comment, ))
        args_chain = set_multiple_regs(commented_args, params, Systems.TargetSystem.Linux)
        if( not args_chain):
            return "Couldn't load arguments in registers"
    else:
        # No arguments 
        args_chain = ROPChain()
    
    args_chain.add_padding(addr, 1, str_ropg(name), offset=True)
    return args_chain


def call_function_linux_x86(func_name, func_args, params):
    
    # Get function address 
    (name, addr) = get_function_address(func_name)
    if( addr is None ):
        return "Couldn't find function '{}' in the binary".format(func_name)
    
    # Check if bad bytes in function address 
    if( not verify_bad_bytes(addr, params.bad_bytes) ):
        return "'{}' address ({}) contains bad bytes".format(func_name, str_special('0x'+format(addr, '0'+str(curr_arch_octets()*2)+'x')))
    
    # Check if lmax too small
    if( (1 + len(func_args) + (lambda x: 1 if len(x)>0 else 0)(func_args)) > params.lmax ):
        return "Not enough bytes to call function '{}'".format(func_name)
    
    # Find a gadget to skip arguments in the stack when returning
    params.single_gadget = True
    params.no_padding = True
    if( func_args ):
        offset = len(func_args)*curr_arch_octets()
        skip_args_chain = None
        i = 0 # Try 4 bytes more maximum 
        while( i < 5 ):
            tmp_offset = offset + i*curr_arch_octets()
            skip_args_res = search( DestArg(DestType.REG, curr_arch_ip()), AssignArg(AssignType.MEM_BINOP_CST, curr_arch_sp(), Binop.ADD, tmp_offset, 0), params)
            if( skip_args_res.found ):
                skip_args_chain = skip_args_res.chain
                break
            i += 1
            
        if( not skip_args_chain ):
            return "Couldn't find return gadget to execute after function"
    else:
        # No arguments 
        skip_args_chain = ROPChain()
    
    # Build the ropchain with the arguments 
    args_chain = ROPChain()
    arg_n = 1
    for arg in func_args:
        if( isinstance(arg, int) ):
            args_chain.add_padding(arg, 1, comment="Arg{}: {}".format(arg_n, str_ropg(hex(arg))))
            arg_n += 1
        else:
            return "Type of argument '{}' not supported yet :'(".format(arg)
    
    # Build call chain (function address + fake return address)
    call_chain = ROPChain()
    call_chain.add_padding(addr, comment=str_ropg(name), offset=True)
    call_chain.add_chain(skip_args_chain)
    call_chain.add_chain(args_chain)
    
    # Return res 
    return call_chain

# ------------------------
# Write a string in memory 
# ------------------------

def _get_valid_padding(octets, bad_bytes):
    """
    Returns a padding of 'octets' bytes
    """
    # Getting a valid padding byte 
    hex_chars = 'fedcba9876543210'
    found = False
    for c1 in hex_chars:
        for c2 in hex_chars:
            c = c1+c2
            byte = int(c,16)
            if( not byte in bad_bytes ):
                res = 0
                for i in range(0, octets):
                    res = res*0x100 + byte
                return res
    return None

def _validate_address(address, bad_bytes):
    for i in range(0, curr_arch_octets()):
        byte = address & 0xff
        if byte in bad_bytes:
            return False
        address = address >> 8
    return True
        
def _biggest_bad_byte_index(address, bad_bytes):
    biggest_find = -1
    for i in range(0, curr_arch_octets()):
        byte = address & 0xff
        if byte in bad_bytes:
            biggest_find = i
        address = address >> 8
    return biggest_find

def _write_decompose_string(string, base_addr, bad_bytes):
    """
    string: string to write
    base_addr: address from which we start to write
    """
    def string_into_reg(string, bad_bytes):
        bytes_list = [b for b in string]
        # Get base value
        if( curr_arch_octets() != len(bytes_list)):
            # If less bytes to write than a register can contain, padd the value
            # Find a valid byte to pad with
            value = _get_valid_padding(curr_arch_octets()-len(bytes_list), bad_bytes)
            if( value is None ):
                return None
        else:
            value = 0
        # Build the full value to put in reg
        if( curr_arch_endianess() == EndiannessType.ENDIAN_LITTLE):
            tmp = 0
            for byte in reversed(bytes_list):
                value = (value << 8) + ord(byte)
            return value
        elif( curr_arch_endianess() == EndianessType.ENDIAN_BIG):
            tmp = 0
            for byte in bytes_list:
                tmp = (tmp << 8) + byte
            return (tmp << (8*len(bytes_list))) + value
        else:
            return None

    res = []
    offset = 0
    while(offset < len(string)):
        # Find the next write address
        step = curr_arch_octets()
        value = string_into_reg(string[offset:offset+step], bad_bytes)
        if( value is None ):
            return (None, None)
        res.append((base_addr+offset, value))
        offset += step
    # Check result
    return res

WRITE_STRING_MAX_TRY = 10 # Maximum base addresses to try  
def _store_string_write_gadget(string, params):
    """
    Copy the string using mem(X) <- Y gadgets 
    Returns (address, ROPChain) or (None, None)
    """
    lower_addr = params.lower_valid_write_addr
    higher_addr = params.higher_valid_write_addr
    tries = 0
    tmp_lower_addr = lower_addr
    saved_lmax = params.lmax
    res = None
    # Try several base addresses
    while( tries < WRITE_STRING_MAX_TRY and tmp_lower_addr + len(string) -1 <= higher_addr):
        # Build chain 
        res = ROPChain()
        offset = 0 
        params.lmax = saved_lmax
        # We decompose the string in substrings to be copied
        writes_list = _write_decompose_string(string, tmp_lower_addr, params.bad_bytes)
        if( writes_list is None):
            res = None
            break
        for (substr_addr,substr_val) in writes_list:
            write_chain_res = search(DestArg(DestType.CSTMEM, substr_addr), AssignArg(AssignType.CST, pycst_to_cppcst(substr_val)), params)
            if( not write_chain_res.found ):
                res = None
                break
            params.lmax -= write_chain_res.chain.len()
            res.add_chain(write_chain_res.chain)
        # Check if result ?
        if( write_chain_res.found ):
            break
        # If not, find bad_byte that caused the search to fail
        bad_index = -1
        for j in reversed(range(0,256)):
            if( write_chain_res.fail_record.get_bad_byte(j) ):
                bad_index = write_chain_res.fail_record.bad_byte_index(j)
                break
        if( bad_index == -1 ):
            # If fail for another reason than bad_bytes, don't try more :/
            res = None
            break
        # Update base_address 
        tries += 1
        tmp_lower_addr += 1<<(8*bad_index)
        tmp_lower_addr &= (2**curr_arch_bits()-1) << (8*bad_index)
    
    params.lmax = saved_lmax
    # Check result 
    if( res is None ):
        return (None, None)
    else:
        return (tmp_lower_addr, res)

# Util function
def _find_valid_delivery_address(lower_addr, higher_addr, substr_lengthes, bad_bytes):
    """
    When writing substrings, a bad address might occur for some of them 
    BASE <- SUB1
    BASE + LEN(SUB1) <- SUB2
    BASE + LEN(SUB1) + LEN(SUB2) -- BAD BYTE IN IT !! :O 
    
    So find another base address that works in the range [lower_addr..higher_addr]
    """
    # Compute the list of addresses that will be used with base and the substring lengthes 
    def get_addr_list(base, substr_lengthes):
        inc = 0
        res = [base]
        for l in substr_lengthes[:-1]: # Don't take the last one because we don't write after 
            inc += l
            res.append(base + inc)
        return res
            
    tmp_lower_addr = lower_addr
    total_length = sum(substr_lengthes)
    while(tmp_lower_addr + total_length <= higher_addr):
        addr_list = get_addr_list(tmp_lower_addr, substr_lengthes)
        for addr in addr_list:
            index = _biggest_bad_byte_index(addr, bad_bytes)
            if( index >= 0 ):
                # Bad byte found 
                # If we tried everything for this byte return 
                if( (tmp_lower_addr & (0xff << index*8)) == (0xff << index*8) ):
                    return None
                # Other wise add 1 and retry 
                tmp_lower_addr += (0x1 << (index*8))
                break
        # No bad bytes found in addresses, return result :) 
        # Else we keep looping 
        if( index == -1 ):
            return tmp_lower_addr
            
    # We reached upper limit to write without finding a good address
    return None

def _store_string_memcpy(string, params, system):
    """
    Copy the string using calls to memcpy() 
    Returns (address, ROPChain) or (None, None)
    """
    lower_addr = params.lower_valid_write_addr
    higher_addr = params.higher_valid_write_addr
    
    # Decompose the string 
    sub_strings = find_bytes(string, params.bad_bytes)
    if( sub_strings is None ):
        return (None, None)
    
    # Find a valid write address
    base_addr = _find_valid_delivery_address(lower_addr, higher_addr, [len(s[1]) for s in sub_strings], params.bad_bytes)
    if( base_addr is None ):
        return (None, None)
        
    # Build chain
    res = ROPChain()
    offset = 0
    tmp_addr = base_addr
    saved_lmax = params.lmax
    per_substring_lmax = params.lmax//len(sub_strings)
    params.lmax = per_substring_lmax
    for (sub_string_addr, sub_string_str) in sub_strings:
        memcpy_chain = call_function("memcpy", [tmp_addr, sub_string_addr, len(sub_string_str)], params, system)
        if( memcpy_chain is None ):
            verbose("Couldn't use memcpy")
            res = None
            break
        elif( isinstance(memcpy_chain, str)):
            verbose("memcpy fail: " + memcpy_chain)
            res = None
            break
        else:
            res.add_chain(memcpy_chain)
        tmp_addr += len(sub_string_str)
    params.lmax = saved_lmax
    if( res is None ):
        return (None, None)
    else:
        return (base_addr, res)

def _store_string_strcpy(string, params, system):
    """
    Copy the string using calls to strcpy() 
    Returns (address, ROPChain) or (None, None)
    """
    lower_addr = params.lower_valid_write_addr
    higher_addr = params.higher_valid_write_addr
    
    # Decompose the string 
    sub_strings = find_bytes(string, params.bad_bytes, add_null=True)
    if( sub_strings is None ):
        return (None, None)
    
    # Find a valid write address
    base_addr = _find_valid_delivery_address(lower_addr, higher_addr, [len(s[1]) for s in sub_strings], params.bad_bytes)
    if( base_addr is None ):
        return (None, None)

    # Build chain
    res = ROPChain()
    offset = 0
    tmp_addr = base_addr
    saved_lmax = params.lmax
    per_substring_lmax = params.lmax//len(sub_strings)
    params.lmax = per_substring_lmax
    for (sub_string_addr, sub_string_str) in sub_strings:
        strcpy_chain = call_function("strcpy", [tmp_addr, sub_string_addr], params, system)
        if( strcpy_chain is None ):
            verbose("Couldn't use strcpy")
            res = None
            break
        elif( isinstance(strcpy_chain, str)):
            verbose("strcpy fail: " + strcpy_chain)
            res = None
            break
        else:
            res.add_chain(strcpy_chain)
        tmp_addr += len(sub_string_str)
    params.lmax = saved_lmax
    if( res is None ):
        return (None, None)
    else:
        return (base_addr, res)
    
def store_string(string, params, system=None):
    """
    Put a string into memory
    return value: 
            a pair (address, ROPChain) or (None, None)
        
    """        
    res_chain = None
    res_addr = None

    # Check if we have valid addresses to write to 
    if( params.lower_valid_write_addr == 0 ):
        verbose("No writable memory specified")
        return (None, None)
    
    # Try with a direct write gadget 
    if(params.shortest or (not res_chain)):
        verbose("Trying with write gadgets only")
        (addr_tmp,chain_tmp) = _store_string_write_gadget(string, params)            
        if( (not res_chain) or (chain_tmp and (chain_tmp.len() < res_chain.len()))):
            res_chain = chain_tmp
            res_addr = addr_tmp

    # Try with memcpy function
    if ((not system is None) and
        (params.shortest or (not res_chain))):
        verbose("Trying with memcpy function")
        (addr_tmp, chain_tmp) = _store_string_memcpy(string, params, system)
        if( (not res_chain) or (chain_tmp and (chain_tmp.len() < res_chain.len()))):
            res_chain = chain_tmp
            res_addr = addr_tmp

    # Try with strcpy function 
    if ((not system is None) and
        (params.shortest or (not res_chain))):
        verbose("Trying with strcpy function")
        (addr_tmp, chain_tmp) = _store_string_strcpy(string, params, system)
        if( (not res_chain) or (chain_tmp and (chain_tmp.len() < res_chain.len()))):
            res_chain = chain_tmp
            res_addr = addr_tmp 

    # Return res
    return (res_addr, res_chain)
